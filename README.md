# Вариант номер 3: генератор синуса
## Начало: запуск
Данная программа реализована на языке c++ стандарта 20 года. На своей локальной машине я её собирал на интел компиляторе с данными флагами:
### icx main.cpp /O2 /std:c++20 /EHsc /Fe:main.exe
После чего запуск осуществлялся посредством запуска main.exe

(К данному файлу будет приложено два файла light.exe и hard.exe - в уже собранные бинарные файлы. В light будут представлены максимальные абсолютные разницы - без детальных отчётов,а в hard будут дополнительные данные)

## Руководство пользователя
В данной программе не предполагается пользовательский ввод, программа сама запускает 50 частот, после чего предлагает пользователю статистику по запускам
Абсолютные ошибки по каждой частоте можно найти в файле Measurments
### Параметры децимации и интерполяции: 
2 в обоих случаях

## Выводы
Чем выше частота синуса, тем больше ошибка при использовании децимации и интерполяции. Всё это вполне логично обосновываеться потерей всё большего числа информации на разных частотах. Чем больше частота синуса, тем меньше шанса "наблюдать" различные значения, что для любой интерполяции является важным. Также может присутсвовать такой момент: если проводить "наивную" децимацию (отбирать каждую n-ю точку), то может возникнуть ситуация, что мы замеряем только в точках 0, когда замеряем 0 и 1 (как при f=50) или только отрицательные и т.д .
